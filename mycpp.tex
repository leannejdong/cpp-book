\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern,footnote, url, hyperref}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{minted}

\newcommand{\be}[1]{\textcolor{blue}{#1}}

\large
\title{A review of Bjarne's small book}
\author{Leanne Dong}
\begin{document}
	\maketitle
	\tableofcontents
\section{The Basics}
\begin{itemize}
	\item Programs
	\item Functions
	\item Types, Variables and Arithmetic
	\item Scope and Lifetime
	\item Constants
	\item Pointers, arrays and References
	\item Tests
	\item Mapping to Hardware
\end{itemize}
\section{User-defined type}
The set of C++ build-in types\footnote{types that can be built from the fundamental types, the const modifier, and the declarator operator} and operations is rich, but deliberately low-level. The directly and efficiently reflect the capabilities of conventional computer hardware. However, they don't provide programmers with high-level facilities to write advanced applications easily. To overcome this, C++ augments the built-in types and operations with a sophisticated set of abstraction mechanisms out of which programmers can build such high-level facilities.

\subsubsection{Strutures}

The first step is building a new type is to putting elements we need into a data structure, a \be{struct}:

\begin{minted}{c++}
struct Vector {
    int sz;    // number of elements
    double* elem; // pointer to elements
};	
\end{minted}
The first version of \be{Vector} consists of an \be{int} and a \be{double*}. A variable of type \be{Vector} can be defined as 
\begin{minted}{c++}
	Vector v;
\end{minted}
However, by itself that is not of much use because v's elem pointer doesn't point to anything. For it to be useful, we must give \be{v} some elements to point to. For instance, construct a \be{Vector} like
\begin{minted}{c++}
void vector_init(Vector& v, int s)
{
    v.elem = new double[s];
    v.sz = s;
}	
\end{minted}
That is, \be{v}'s \be{elem} member gets a pointer produced by the \be{new} operator, and \be{v}'s \be{sz} member gets the number of elements. The \be{\&} in \be{Vector\&} indicates that we pass \be{v} by non-\be{const} ref, so that \be{vector\_init()} can modify the vector passed to it.

The \be{new} operator allocates memory from \emph{free store} (also known as \emph{dynamic memory, or heap} ).
Object allocated on the free store are independent of the scopt from which they are created and live until they are destroyed using the \be{delete} operator.

A simple implementation of \be{Vector} could be 
\begin{minted}{c++}
double read_and_sum(int s)
// read s integers from cin and return their sum, s is //assumed to be positive
{
    Vector v;
    vector_init(v, s); // allocate s elements for v
    for (int i = 0; i!=s; ++i)
    {
        std::cin >> v.elem[i]; // read into elements
    }
    double sum = 0;
    for (int i = 0; i!=s; ++i)
    {
        sum+=v.elem[i];
    }
    std::cout << sum << " \n";
    return sum;
}

int main()
{
    read_and_sum(10);
}	
\end{minted}
There was a long to go from above to the elegant \be{std::vector}.

Compiler Explorer: \url{https://godbolt.org/z/vjEMeP}

We use \be{.}(dot) to access \be{struct} members through a name (and through a reference) and \be{->} to access 
\be{struct} members through a pointer. For instance

\begin{minted}{c++}
void f(Vector v, Vector& rv, Vector* pv)
{
    int i1 = v.sz; // access through name
    int i2 = rv.sz; // access through reference
    int i3 = pv->sz; // access through pointer
}
\end{minted}


Now another example from Herb's talk.
\begin{minted}{c++}
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

struct User {
    std::string name;
    int age;
};

std::vector<User> users = { {"Cat", 3}, {"Fish", 5} };

int main()
{
    auto sort_by_age = [] (auto& lhs, auto& rhs)
    {
        return lhs.age < rhs.age;
    };

    std::sort(users.begin(), users.end(), sort_by_age);
}
\end{minted}
Compiler explorer: \url{https://godbolt.org/z/noea68}

\subsubsection{Classes}
From the \be{struct} example we see that having the data specified separately from the operations on it 
has advantages. Now we will establish a tighter connection between the representation and the operations for a user-defined type to have all the properties of a `real type'. Specifically, we should keep representation inaccessible to users so as to ease use, ensure consistent use of the data, and allow us to later improve the representation. To this end, we need to distinguish
\begin{enumerate}
	\item The interface
	\item A type (to be used by all)
	\item The implementation of the type (which has access to the otherwise inaccessible data)
\end{enumerate}
The is the so-called class. Class provides greater level of abstractions compared to struct.The interface is defined by the \be{public} member of a class, and \be{private} members are accessible only through that interface. For instance,
\begin{minted}{c++}
	class Vector {
	
	
	}
\end{minted}
\subsubsection{Unions}

\subsubsection{Unions}

\subsubsection{Enumerations}
% \section*{Exercise 1}
% \subsection*{main.cpp}
% \begin{minted}[frame=lines, linenos, fontsize=\large]
% {c++}
% #include "header.ih"
%
% int main()
% {
%     fn1();
%     fn2();
% }
% \end{minted}

\section{Modularity}

\section{Classes}

\section{Essential Operations}

\section{Templates}

\section{Concepts and Generic Programming}

\section{Library Overview}

\section{String and Regular Expression}

\section{Input and Output}

\section{Containers}

\section{Algorithms}

\section{Utilities}

\section{Numerics}

\section{Concurrency}

\section{History and Compatibility}

\end{document}











